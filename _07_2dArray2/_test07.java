package _07_2dArray2;

public class _test07 {

	public static void main(String[] args) {
		int[] save = new int [5000];	// 1~5000까지 저장할 배열
		int[] max = new int [5000];		// 제너레이터들을 저장할 배열
		int sum = 0;					// 셀프넘버들이 더해질 변수
		
		// System.out.println(96/10 + 96 % 10 + 96); // 9 + 6 = 15 + 96 = 111 
		
		// e.g) 예시에 따르면 111의 제너레이터는 96이다. 111의 제너레이터는 따로 더 있을 수있지만 찾을 필요 x 제너레이터가 하나라도 있다면 어차피 제거해야한다.
		
		// System.out.println(1 + (1 % 10) + 1/10); 10의 자리까지 가능한 계산식
		
		// System.out.println(1000 + (1000 % 10) + (1000 % 100)/10 + (1000 % 1000)/100 + 1000/1000);	1000자리 숫자까지 계산 가능한 식
		
		for(int i = 1; i <= 5000; i++) {			// 1 부터 5000이 저장 된 5000개의 인덱스가 있는 save배열을 만든다
			save[i-1] = i;
		}
		
		for(int i = 0; i < 5000; i++) {
			max[i] = save[i] + save[i]%10 + (save[i]%100)/10 + (save[i]%1000)/100 + save[i]/1000;
							// 1이 제너레이터가 되는 숫자들을 저장, 2가 제너레이터가 되는... 의 반복을 5000까지 해준다. 이를 max 배열에 저장한다
							// 이렇게 되면 제너레이터를 가진 숫자만 max배열에 저장된다 ★★★
		}					// 셀프 넘버들은 제너레이터가 없기 때문에 max배열에는 존재하지 않게 된다 ★★★
							// 이렇게 된다면, save배열에서 max배열에 있는 숫자들만 제거하면 알아서 셀프넘버만 남게 된다.
							// 방식은, 제너레이터를 가진 수를 발견하면 해당 수를 0으로 만든다. 결과적으로, 0이 아닌 수들은 셀프넘버들 뿐이다.
		
		for(int i = 0; i < 5000;  i++) {
			for(int j = 0; j < 5000; j++) {	
			if(save[i] == max[j] ) {			// save 가 i 번째 인덱스 일 때 max의 5000배열을 전부 조회한다. 하나라도 같은 수가 존재하면 셀프넘버가 아니기에
				save[i] = 0;					// 해당 i 배열을 즉시 0으로 만들어버린다.
			}									// 즉, 셀프넘버가 아닌 숫자들은 전부 0으로 만든다.
			}
			sum+=save[i];						// 세이브 배열에 남은 것은 이미 0이 된 수천개의 제너레이터 + 셀프 넘버들 뿐이라 sum변수는 0 + 셀프넘버들이 된다.
		}
		System.out.println(sum);				// 셀프넘버의 합을 출력한다
												// 어차피 save배열에는 5000이 넘는 수는 존재하지 않기 때문에 max배열에 남아있는 5000이 넘는 수들은 의미 x	

	}

}
